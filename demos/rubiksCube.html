<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
        }
        canvas {
            
        }
        #log {
        	z-index: 2;
            position: absolute;
            top:0;
            left:0;
            color:white;
        }
        #arrowUp {
        	bottom: 14rem;
            right: 8rem;
            transform: rotate(180deg);
        }
        #arrowLeft {
        	bottom: 11rem;
            right: 11rem;
            transform: rotate(90deg);
        }
        #arrowRight {
        	bottom: 11rem;
            right: 5rem;
            transform: rotate(270deg);
        }
        #arrowDown {
        	bottom: 8rem;
            right: 8rem;
        }
        #controls button {
        	font-size: 2rem;
            position: absolute;
            z-index: 2;
            padding: 0.5rem;
        }
        #controls button::before {
        	content: "V";
        }
        #faceControls {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            z-index: 2;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        #faceControls button {
            font-size: 1.5rem;
            padding: 0.5rem 1rem;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            color: white;
            cursor: pointer;
            
        }
        #faceControls button:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
	<div id="canvas"></div>
	<div id="controls">
         <button id="arrowUp" onclick="rotateUp();"></button>
         <button id="arrowLeft" onclick="rotateLeft()"></button>
         <button id="arrowRight" onclick="rotateRight()"></button>
         <button id="arrowDown" onclick="rotateDown()"></button>
     </div>
     <div id="faceControls">
         <button onclick="rotateFace('front', true)">F</button>
         <button onclick="rotateFace('front', false)">F'</button>
         <button onclick="rotateFace('back', true)">B</button>
         <button onclick="rotateFace('back', false)">B'</button>
         <button onclick="rotateFace('left', true)">L</button>
         <button onclick="rotateFace('left', false)">L'</button>
         <button onclick="rotateFace('right', true)">R</button>
         <button onclick="rotateFace('right', false)">R'</button>
         <button onclick="rotateFace('top', true)">U</button>
         <button onclick="rotateFace('top', false)">U'</button>
         <button onclick="rotateFace('bottom', true)">D</button>
         <button onclick="rotateFace('bottom', false)">D'</button>
     </div>
    <!-- dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-29/epiccanvas.js" crossorigin='anonymous'></script>

    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-29/shaders/vertexPhong.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-29/shaders/fragmentPhong.js" crossorigin='anonymous'></script>

    <script>
    	const n = 3 // 1, 2 or 3 only for playable game
    	const cellSize = 2;
    	const gap = 0.05
    	const step = cellSize + gap;
    	const offset = (n - 1) * step / 2;
    	
    function Rubik(ec, i, j, k, n, initBuffers = true){
    const vertices=[
        -1,-1,1,1,
        -1,1,1,1,
        1,-1,1,1,
        -1,1,1,1,
        1,-1,1,1,
        1,1,1,1,
        1,-1,1,1,
        1,1,1,1,
        1,-1,-1,1,
        1,1,1,1,
        1,-1,-1,1,
        1,1,-1,1,
        1,-1,-1,1,
        1,1,-1,1,
        -1,-1,-1,1,
        1,1,-1,1,
        -1,-1,-1,1,
        -1,1,-1,1,
        -1,-1,-1,1,
        -1,1,-1,1,
        -1,-1,1,1,
        -1,1,-1,1,
        -1,-1,1,1,
        -1,1,1,1,
        -1,1,1,1,
        -1,1,-1,1,
        1,1,1,1,
        -1,1,-1,1,
        1,1,1,1,
        1,1,-1,1,
        -1,-1,1,1,
        -1,-1,-1,1,
        1,-1,1,1,
        -1,-1,-1,1,
        1,-1,1,1,
        1,-1,-1,1
    ];
    let colors = new Array(36 * 4).fill(0); // all black initially
    // Front face (White) if on front
    if (k === n - 1) {
        for (let p = 0; p < 6; p++) {
            colors[p * 4] = 1.0;
            colors[p * 4 + 1] = 1.0;
            colors[p * 4 + 2] = 1.0;
            colors[p * 4 + 3] = 1.0;
        }
    }
    // Right face (Red) if on right
    if (i === n - 1) {
        for (let p = 6; p < 12; p++) {
            colors[p * 4] = 1.0;
            colors[p * 4 + 1] = 0.0;
            colors[p * 4 + 2] = 0.0;
            colors[p * 4 + 3] = 1.0;
        }
    }
    // Back face (Yellow) if on back
    if (k === 0) {
        for (let p = 12; p < 18; p++) {
            colors[p * 4] = 1.0;
            colors[p * 4 + 1] = 1.0;
            colors[p * 4 + 2] = 0.0;
            colors[p * 4 + 3] = 1.0;
        }
    }
    // Left face (Orange) if on left
    if (i === 0) {
        for (let p = 18; p < 24; p++) {
            colors[p * 4] = 1.0;
            colors[p * 4 + 1] = 0.5;
            colors[p * 4 + 2] = 0.0;
            colors[p * 4 + 3] = 1.0;
        }
    }
    // Top face (Blue) if on top
    if (j === n - 1) {
        for (let p = 24; p < 30; p++) {
            colors[p * 4] = 0.0;
            colors[p * 4 + 1] = 0.0;
            colors[p * 4 + 2] = 1.0;
            colors[p * 4 + 3] = 1.0;
        }
    }
    // Bottom face (Green) if on bottom
    if (j === 0) {
        for (let p = 30; p < 36; p++) {
            colors[p * 4] = 0.0;
            colors[p * 4 + 1] = 1.0;
            colors[p * 4 + 2] = 0.0;
            colors[p * 4 + 3] = 1.0;
        }
    }
    const textureCoordinates=[
        0.0,1.0,
        0.0,0.0,
        1.0,1.0,
        0.0,0.0,
        1.0,1.0,
        1.0,0.0,
        0.0,1.0,
        0.0,0.0,
        1.0,1.0,
        0.0,0.0,
        1.0,1.0,
        1.0,0.0,
        0.0,1.0,
        0.0,0.0,
        1.0,1.0,
        0.0,0.0,
        1.0,1.0,
        1.0,0.0,
        0.0,1.0,
        0.0,0.0,
        1.0,1.0,
        0.0,0.0,
        1.0,1.0,
        1.0,0.0,
        0.0,1.0,
        0.0,0.0,
        1.0,1.0,
        0.0,0.0,
        1.0,1.0,
        1.0,0.0,
        0.0,1.0,
        0.0,0.0,
        1.0,1.0,
        0.0,0.0,
        1.0,1.0,
        1.0,0.0,
    ]
    const normals=[
        0,0,1,0,
        0,0,1,0,
        0,0,1,0,
        0,0,1,0,
        0,0,1,0,
        0,0,1,0,
        
        1,0,0,0,
        1,0,0,0,
        1,0,0,0,
        1,0,0,0,
        1,0,0,0,
        1,0,0,0,
        
        0,0,-1,0,
        0,0,-1,0,
        0,0,-1,0,
        0,0,-1,0,
        0,0,-1,0,
        0,0,-1,0,
        
        -1,0,0,0,
        -1,0,0,0,
        -1,0,0,0,
        -1,0,0,0,
        -1,0,0,0,
        -1,0,0,0,
        
        0,1,0,0,
        0,1,0,0,
        0,1,0,0,
        0,1,0,0,
        0,1,0,0,
        0,1,0,0,
        
        0,-1,0,0,
        0,-1,0,0,
        0,-1,0,0,
        0,-1,0,0,
        0,-1,0,0,
        0,-1,0,0
    ]
    const mode=ec.gl.TRIANGLES
    const shape={vertices,colors,textureCoordinates,mode,normals}
    if(initBuffers)
        ec.initBuffers(shape)
    return shape
}
    
    
        //globals
        let rubikCells = [], program, ec;
        let oldt=0
        let animating = false;
        let animation = null;
         

        function render(t) {
        	let dt = t-oldt;
            oldt = t;
            try {
            	ec.clearScreen();
            	for(let i=0; i<n; i++)
                for(let j=0; j<n; j++)
                for(let k=0; k<n; k++)
                     if(rubikCells[i][j][k]) ec.drawShape(program, rubikCells[i][j][k]);
                if(animation){
                  let delta_angle = animation.speed * dt;
                  if(Math.abs(delta_angle) > Math.abs(animation.remaining)){
                    delta_angle = animation.remaining;
                  }
                  for(let cell of animation.cells){
                    ec.rotateModelMatrix(cell, delta_angle, animation.axis);
                  }
                  animation.remaining -= delta_angle;
                  if(Math.abs(animation.remaining) < 0.001){
                    updateGrid(animation.cells);
                    animation = null;
                    animating = false;
                  }
                }
                requestAnimationFrame(render);
                ec.pointLightPosition= [Math.cos(t/3000)*5, Math.sin(t/3000)*5,12]
            } catch(e) {
                alert(e)
            }
        }
        
        function updateGrid(selected_cells) {
          let newCells = Array(n).fill(0).map(() => Array(n).fill(0).map(() => Array(n).fill(null)));
          for(let i=0; i<n; i++){
            for(let j=0; j<n; j++){
              for(let k=0; k<n; k++){
                let cell = rubikCells[i][j][k];
                if(cell && !selected_cells.includes(cell)){
                  newCells[i][j][k] = cell;
                }
              }
            }
          }
          for(let cell of selected_cells){
            let worldPos = ec.getWorldPosition(cell);
            let x = worldPos[0];
            let y = worldPos[1];
            let z = worldPos[2];
            let ix = Math.round((x + offset) / step);
            let jy = Math.round((y + offset) / step);
            let kz = Math.round((z + offset) / step);
            ix = Math.max(0, Math.min(n-1, ix));
            jy = Math.max(0, Math.min(n-1, jy));
            kz = Math.max(0, Math.min(n-1, kz));
            newCells[ix][jy][kz] = cell;
          }
          rubikCells = newCells;
        }
        
        function doRotation(matcher, angle, axis) {
          if(animating) return;
          animating = true;
          let selected = [];
          for(let i=0; i<n; i++){
            for(let j=0; j<n; j++){
              for(let k=0; k<n; k++){
                if(matcher(i,j,k) && rubikCells[i][j][k]){
                  selected.push(rubikCells[i][j][k]);
                }
              }
            }
          }
          const duration = 500;
          animation = {
            cells: selected,
            axis: axis,
            speed: angle / duration,
            remaining: angle
          };
        }
        
       function rotateUp(){
         doRotation((i,j,k)=>true, -Math.PI/2, [1,0,0]);
       } 
       
       function rotateLeft(){
         doRotation((i,j,k)=>true, -Math.PI/2, [0,1,0]);
       } 
       
       function rotateRight(){
         doRotation((i,j,k)=>true, Math.PI/2, [0,1,0]);
       } 
       
       function rotateDown(){
         doRotation((i,j,k)=>true, Math.PI/2, [1,0,0]);
       } 

        function rotateFace(face, isCW) {
          let axis, matcher, cw_sign;
          switch(face){
            case 'front':
              axis = [0,0,1];
              cw_sign = -1;
              matcher = (i,j,k) => k === n-1;
              break;
            case 'back':
              axis = [0,0,1];
              cw_sign = 1;
              matcher = (i,j,k) => k === 0;
              break;
            case 'right':
              axis = [1,0,0];
              cw_sign = -1;
              matcher = (i,j,k) => i === n-1;
              break;
            case 'left':
              axis = [1,0,0];
              cw_sign = 1;
              matcher = (i,j,k) => i === 0;
              break;
            case 'top':
              axis = [0,1,0];
              cw_sign = -1;
              matcher = (i,j,k) => j === n-1;
              break;
            case 'bottom':
              axis = [0,1,0];
              cw_sign = 1;
              matcher = (i,j,k) => j === 0;
              break;
          }
          const angle = (isCW ? cw_sign : -cw_sign) * Math.PI / 2;
          doRotation(matcher, angle, axis);
        }

        const main = async () => {
            try {
            	const size = innerWidth<innerHeight?innerWidth:innerHeight;
                // create canvas
                const width = size;
                const height = size;
                ec = new EpicCanvas(width,height,"#canvas");
                ec.aspectRatio = width/height
                ec.fieldOfView = Math.PI/3

                // create objects
                rubikCells = Array(n).fill(0).map(() => Array(n).fill(0).map(() => Array(n).fill(null)));
                for(let i=0;i<n;i++){
                	for(let j=0;j<n;j++){
                	    for(let k=0;k<n;k++){
                            let rubik = Rubik(ec, i, j, k, n);
                            ec.translateModelMatrix(rubik, [i*step - offset, j*step - offset, k*step - offset])
                            rubikCells[i][j][k] = rubik;
                            rubik.shininess = 200
                        }
                    }
                }
                
                // create shader program
                program = ec.makeProgram(vsPhong, fsPhong)
    
                // setup camera
                ec.lookAt([0,0,8/2*n], [0,0,0], [0,1,0]);
                
                // setup lighting
            //    ec.ambientColor = [0.2,0.2,0.2];
                ec.pointLightPosition = [12,16,16]
                ec.pointLightColor = [0.8,0.8,0.8]
              
                requestAnimationFrame(render);
            } catch(e) {
                alert("error in main:"+e);
            }

            // Add keyboard listener for side rotations
            document.addEventListener('keydown', (event) => {
              if(animating) return;
              const key = event.key;
              let face, isCW;
              if (key === 'F') { face = 'front'; isCW = true; }
              else if (key === 'f') { face = 'front'; isCW = false; }
              else if (key === 'B') { face = 'back'; isCW = true; }
              else if (key === 'b') { face = 'back'; isCW = false; }
              else if (key === 'R') { face = 'right'; isCW = true; }
              else if (key === 'r') { face = 'right'; isCW = false; }
              else if (key === 'L') { face = 'left'; isCW = true; }
              else if (key === 'l') { face = 'left'; isCW = false; }
              else if (key === 'U') { face = 'top'; isCW = true; }
              else if (key === 'u') { face = 'top'; isCW = false; }
              else if (key === 'D') { face = 'bottom'; isCW = true; }
              else if (key === 'd') { face = 'bottom'; isCW = false; }
              if (face) {
                rotateFace(face, isCW);
              }
            });
        }

        onload = main;
    </script>
</body>
</html>
